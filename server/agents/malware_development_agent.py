#!/usr/bin/env python3
"""
Malware Development Agent
==========================

Autonomous end-to-end malware development workflow orchestrator.
Coordinates technique selection, code assembly, OPSEC optimization,
and compilation.

Author: Noctis-MCP Community
License: MIT
"""

import sys
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from typing import Dict, List, Tuple
from server.agents.base_agent import BaseAgent, AgentResult
from server.agents.technique_selection_agent import TechniqueSelectionAgent
from server.agents.opsec_optimization_agent import OpsecOptimizationAgent
from server.agents.learning_agent import LearningAgent


class MalwareDevelopmentAgent(BaseAgent):
    """
    Autonomous malware development from goal to binary.

    This is the main orchestrator agent that coordinates all other agents
    to provide a complete workflow from high-level goal to compiled malware.

    Workflow:
        1. Analyze goal and select optimal techniques (TechniqueSelectionAgent)
        2. Assemble code from selected techniques (CodeAssembler)
        3. Optimize for OPSEC (OpsecOptimizationAgent)
        4. Optionally compile (Compiler)
        5. Record feedback (LearningAgent)

    Input Parameters:
        - goal (str): High-level description of what malware should do
        - target_av (str): Target AV/EDR (default: 'Windows Defender')
        - target_os (str): Target OS (default: 'Windows')
        - architecture (str): Target architecture (default: 'x64')
        - auto_compile (bool): Automatically compile (default: True)
        - target_opsec_score (float): Target OPSEC score (default: 8.0)
        - max_techniques (int): Max techniques to use (default: 5)
        - complexity (str): Complexity level (default: 'medium')

    Output:
        AgentResult with:
            - source_code: Generated and optimized source code
            - binary_path: Path to compiled binary (if auto_compile=True)
            - techniques_used: List of technique IDs used
            - opsec_score: Final OPSEC score
            - compilation_success: Whether compilation succeeded
            - workflow_summary: Summary of each step
    """

    def _init_agent(self):
        """Initialize agent-specific resources"""
        self.logger.info("Initializing MalwareDevelopmentAgent...")

        # Initialize RAG engine
        try:
            from server.rag import RAGEngine
            rag_path = self.config.get('rag_db_path', 'data/rag_db')
            self.rag_engine = RAGEngine(persist_dir=rag_path)
            self.logger.info("RAG engine initialized for code assembly")
        except Exception as e:
            self.logger.warning(f"RAG engine not available: {e}")
            self.rag_engine = None

        # Initialize sub-agents
        self.technique_agent = TechniqueSelectionAgent(self.config)
        self.opsec_agent = OpsecOptimizationAgent(self.config)
        self.learning_agent = LearningAgent(self.config)

        # Initialize code assembler with RAG
        from server.code_assembler import CodeAssembler
        self.assembler = CodeAssembler(rag_engine=self.rag_engine)

        # Initialize compiler
        try:
            from compilation import get_compiler
            output_dir = self.config.get('output_dir', 'compiled')
            self.compiler = get_compiler(output_dir=output_dir)
            self.compiler_available = True
        except Exception as e:
            self.logger.warning(f"Compiler not available: {e}")
            self.compiler = None
            self.compiler_available = False

        self.logger.info("MalwareDevelopmentAgent initialized")

    def validate_inputs(self, **kwargs) -> Tuple[bool, List[str]]:
        """Validate input parameters"""
        errors = []

        # goal is required
        goal = kwargs.get('goal')
        if not goal:
            errors.append("goal parameter is required")
        elif not isinstance(goal, str):
            errors.append("goal must be a string")

        # target_opsec_score is optional (defaults to 8.0)
        target_opsec_score = kwargs.get('target_opsec_score', 8.0)
        if not isinstance(target_opsec_score, (int, float)):
            errors.append("target_opsec_score must be a number")
        elif not (0 <= target_opsec_score <= 10):
            errors.append("target_opsec_score must be between 0 and 10")

        # max_techniques is optional (defaults to 5)
        max_techniques = kwargs.get('max_techniques', 5)
        if not isinstance(max_techniques, int):
            errors.append("max_techniques must be an integer")
        elif max_techniques < 1 or max_techniques > 20:
            errors.append("max_techniques must be between 1 and 20")

        return len(errors) == 0, errors

    def execute(self, **kwargs) -> AgentResult:
        """Execute autonomous malware development workflow"""
        # Extract parameters
        goal = kwargs.get('goal')
        target_av = kwargs.get('target_av', 'Windows Defender')
        target_os = kwargs.get('target_os', 'Windows')
        architecture = kwargs.get('architecture', 'x64')
        auto_compile = kwargs.get('auto_compile', True)
        target_opsec_score = kwargs.get('target_opsec_score', 8.0)
        max_techniques = kwargs.get('max_techniques', 5)
        complexity = kwargs.get('complexity', 'medium')

        self.logger.info(f"Starting malware development workflow")
        self.logger.info(f"  Goal: {goal}")
        self.logger.info(f"  Target: {target_av} on {target_os}/{architecture}")

        workflow_summary = []
        warnings = []

        try:
            # STEP 1: Select Techniques
            self.logger.info("STEP 1: Selecting optimal techniques...")
            objective = self._infer_objective(goal)

            selection_result = self.technique_agent.run(
                target_av=target_av,
                objective=objective,
                complexity=complexity,
                constraints={'max_techniques': max_techniques}
            )

            if not selection_result.success:
                return AgentResult(
                    success=False,
                    data={},
                    errors=selection_result.errors,
                    warnings=[],
                    metadata={'step_failed': 'technique_selection'}
                )

            techniques = selection_result.data['selected_techniques']
            workflow_summary.append({
                'step': 'technique_selection',
                'status': 'success',
                'techniques_selected': techniques,
                'execution_time': selection_result.execution_time
            })

            self.logger.info(f"  Selected {len(techniques)} techniques: {techniques}")

            # STEP 2: Assemble Code
            self.logger.info("STEP 2: Assembling code from techniques...")
            try:
                assembly_result = self.assembler.assemble(techniques)
                source_code = assembly_result.source_code

                workflow_summary.append({
                    'step': 'code_assembly',
                    'status': 'success',
                    'lines_of_code': len(source_code.split('\n')),
                    'dependencies': assembly_result.dependencies,
                    'conflicts': assembly_result.conflicts
                })

                if assembly_result.warnings:
                    warnings.extend(assembly_result.warnings)

                self.logger.info(f"  Assembled {len(source_code.split('\n'))} lines of code")

            except Exception as e:
                self.logger.exception(f"Code assembly failed: {e}")  # Use .exception for full traceback
                return AgentResult(
                    success=False,
                    data={},
                    errors=[f"Code assembly failed: {str(e)}"],
                    warnings=[],
                    metadata={'step_failed': 'code_assembly'}
                )

            # STEP 3: Optimize OPSEC
            self.logger.info(f"STEP 3: Optimizing OPSEC (target: {target_opsec_score})...")
            opsec_result = self.opsec_agent.run(
                code=source_code,
                target_score=target_opsec_score,
                max_iterations=3
            )

            if not opsec_result.success:
                # OPSEC optimization failure is not fatal
                self.logger.warning(f"OPSEC optimization failed, using unoptimized code")
                warnings.append("OPSEC optimization failed")
                optimized_code = source_code
                opsec_score = 0.0
            else:
                optimized_code = opsec_result.data['optimized_code']
                opsec_score = opsec_result.data['final_score']
                workflow_summary.append({
                    'step': 'opsec_optimization',
                    'status': 'success',
                    'original_score': opsec_result.data['original_score'],
                    'final_score': opsec_score,
                    'iterations': opsec_result.data['iterations_used'],
                    'execution_time': opsec_result.execution_time
                })

                self.logger.info(f"  OPSEC score: {opsec_score:.2f}/10")

            # STEP 4: Compile (if requested)
            binary_path = None
            compilation_success = False

            if auto_compile:
                if not self.compiler_available:
                    warnings.append("Compiler not available, skipping compilation")
                    self.logger.warning("Compiler not available")
                else:
                    self.logger.info("STEP 4: Compiling binary...")
                    try:
                        compile_result = self.compiler.compile(
                            source_code=optimized_code,
                            architecture=architecture,
                            optimization='O2',
                            output_name=f'noctis_payload_{target_av.lower().replace(" ", "_")}',
                            subsystem='Console'
                        )

                        compilation_success = compile_result.success

                        if compile_result.success:
                            binary_path = compile_result.binary_path
                            workflow_summary.append({
                                'step': 'compilation',
                                'status': 'success',
                                'binary_path': binary_path,
                                'compilation_time': compile_result.compilation_time
                            })
                            self.logger.info(f"  Compiled successfully: {binary_path}")
                        else:
                            warnings.append(f"Compilation failed: {compile_result.errors}")
                            workflow_summary.append({
                                'step': 'compilation',
                                'status': 'failed',
                                'errors': compile_result.errors
                            })
                            self.logger.warning("  Compilation failed")

                    except Exception as e:
                        self.logger.error(f"Compilation error: {e}")
                        warnings.append(f"Compilation error: {str(e)}")

            # STEP 5: Record Learning Feedback
            self.logger.info("STEP 5: Recording compilation feedback...")
            try:
                learning_result = self.learning_agent.run(
                    action='record_compilation',
                    techniques=techniques,
                    success=compilation_success,
                    compiler='MSBuild' if self.compiler_available else 'N/A'
                )

                if learning_result.success:
                    workflow_summary.append({
                        'step': 'learning_feedback',
                        'status': 'success'
                    })
            except Exception as e:
                self.logger.warning(f"Failed to record learning feedback: {e}")
                warnings.append("Learning feedback not recorded")

            # Build final result
            self.logger.info("Workflow complete!")

            return AgentResult(
                success=True,
                data={
                    'source_code': optimized_code,
                    'binary_path': binary_path,
                    'techniques_used': techniques,
                    'technique_details': selection_result.data.get('technique_details', []),
                    'opsec_score': opsec_score,
                    'compilation_success': compilation_success,
                    'workflow_summary': workflow_summary,
                    'metadata': {
                        'goal': goal,
                        'target_av': target_av,
                        'target_os': target_os,
                        'architecture': architecture,
                        'objective': objective
                    }
                },
                errors=[],
                warnings=warnings,
                metadata={
                    'total_steps': len(workflow_summary),
                    'all_steps_successful': all(s['status'] == 'success' for s in workflow_summary)
                }
            )

        except Exception as e:
            self.logger.exception(f"Malware development workflow failed: {e}")
            return AgentResult(
                success=False,
                data={'workflow_summary': workflow_summary},
                errors=[f"Workflow failed: {str(e)}"],
                warnings=warnings,
                metadata={'step_failed': 'unknown'}
            )

    def _infer_objective(self, goal: str) -> str:
        """
        Infer objective from goal description.

        Args:
            goal: High-level goal description

        Returns:
            Objective string ('evasion', 'stealth', 'persistence', 'injection', 'all')
        """
        goal_lower = goal.lower()

        # Check for keywords
        if 'evade' in goal_lower or 'bypass' in goal_lower or 'avoid detection' in goal_lower:
            return 'evasion'
        elif 'stealthy' in goal_lower or 'stealth' in goal_lower or 'covert' in goal_lower:
            return 'stealth'
        elif 'persist' in goal_lower or 'maintain access' in goal_lower:
            return 'persistence'
        elif 'inject' in goal_lower or 'process injection' in goal_lower:
            return 'injection'
        else:
            # Default to evasion
            return 'evasion'


# Example usage
if __name__ == '__main__':
    # Test the agent
    config = {
        'db_path': 'data/knowledge_base.db',
        'metadata_path': 'techniques/metadata',
        'output_dir': 'compiled'
    }

    agent = MalwareDevelopmentAgent(config)

    result = agent.run(
        goal="Create a stealthy loader that evades Windows Defender using API hashing and syscalls",
        target_av="Windows Defender",
        target_os="Windows",
        architecture="x64",
        auto_compile=False,  # Skip compilation for test
        target_opsec_score=8.0,
        max_techniques=3
    )

    print(result)
    if result.success:
        print(f"\nâœ“ Malware development successful!")
        print(f"  Techniques: {result.data['techniques_used']}")
        print(f"  OPSEC Score: {result.data['opsec_score']:.2f}/10")
        print(f"  Steps completed: {len(result.data['workflow_summary'])}")
