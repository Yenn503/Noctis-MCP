#!/usr/bin/env python3
"""
Multi-file Code Assembler
==========================

Enhances the code assembler to generate modular multi-file projects.

Features:
- Splits techniques into logical modules
- Generates header files
- Creates proper project structure
- Manages dependencies between files

Author: Noctis-MCP Community
License: MIT
"""

import logging
from typing import List, Dict, Set
from compilation.multi_file_compiler import ProjectStructure, ProjectFile
from server.code_assembler import CodeAssembler, GeneratedCode


logger = logging.getLogger(__name__)


class ModuleSplitter:
    """
    Splits techniques into logical modules
    """
    
    # Module categories
    MODULE_CATEGORIES = {
        'syscalls': ['syscall', 'hellshall', 'trapflag', 'indirect'],
        'injection': ['inject', 'hollowing', 'apc', 'thread'],
        'evasion': ['unhook', 'edr', 'anti', 'detection'],
        'encryption': ['encrypt', 'decrypt', 'aes', 'xor', 'rc4'],
        'obfuscation': ['hash', 'api_hash', 'camouflage', 'obfuscate'],
        'memory': ['alloc', 'protect', 'virtual', 'heap'],
        'network': ['socket', 'http', 'c2', 'download'],
        'persistence': ['registry', 'startup', 'service', 'schedule'],
    }
    
    def categorize_technique(self, technique_name: str) -> str:
        """
        Determine which module a technique belongs to
        
        Args:
            technique_name: Name of the technique
        
        Returns:
            Module name (e.g., 'syscalls', 'injection', 'utils')
        """
        name_lower = technique_name.lower()
        
        for module, keywords in self.MODULE_CATEGORIES.items():
            if any(keyword in name_lower for keyword in keywords):
                return module
        
        # Default to utils
        return 'utils'
    
    def split_techniques(self, techniques: List[Dict]) -> Dict[str, List[Dict]]:
        """
        Split techniques into modules
        
        Args:
            techniques: List of technique metadata
        
        Returns:
            Dict mapping module names to technique lists
        """
        modules = {}
        
        for technique in techniques:
            module = self.categorize_technique(technique.get('name', ''))
            if module not in modules:
                modules[module] = []
            modules[module].append(technique)
        
        logger.info(f"Split {len(techniques)} techniques into {len(modules)} modules")
        for module, techs in modules.items():
            logger.info(f"  {module}: {len(techs)} techniques")
        
        return modules


class HeaderGenerator:
    """
    Generates header files for modules
    """
    
    def generate_header(self, module_name: str, functions: List[str]) -> str:
        """
        Generate a header file for a module
        
        Args:
            module_name: Name of the module
            functions: List of function signatures
        
        Returns:
            Header file content
        """
        guard_name = f"{module_name.upper()}_H"
        
        header = f"""#ifndef {guard_name}
#define {guard_name}

#include <windows.h>

// {module_name.capitalize()} module - Auto-generated by Noctis-MCP

"""
        
        # Add function declarations
        for func in functions:
            # Extract function signature (simple regex-based)
            import re
            match = re.match(r'([\w\s\*]+)\s+(\w+)\s*\((.*?)\)', func)
            if match:
                return_type = match.group(1).strip()
                func_name = match.group(2)
                params = match.group(3)
                header += f"{return_type} {func_name}({params});\n"
        
        header += f"\n#endif // {guard_name}\n"
        
        return header


class MultiFileAssembler:
    """
    Assembles techniques into multi-file projects
    
    Extends CodeAssembler to generate modular project structures.
    """
    
    def __init__(self):
        self.base_assembler = CodeAssembler()
        self.module_splitter = ModuleSplitter()
        self.header_generator = HeaderGenerator()
    
    def assemble_project(self, technique_ids: List[str],
                        project_name: str = "malware_project",
                        target_os: str = "Windows",
                        payload_type: str = "loader") -> ProjectStructure:
        """
        Assemble techniques into a multi-file project
        
        Args:
            technique_ids: List of technique IDs to combine
            project_name: Name for the project
            target_os: Target operating system
            payload_type: Type of payload
        
        Returns:
            ProjectStructure with all files
        """
        logger.info(f"Assembling multi-file project: {project_name}")
        logger.info(f"  Techniques: {len(technique_ids)}")
        
        # First, use base assembler to get basic code
        base_result = self.base_assembler.assemble(technique_ids)
        
        # GeneratedCode doesn't have success attribute, just check if source_code is empty
        if not base_result.source_code or len(base_result.source_code) < 50:
            logger.error("Base assembly failed")
            # Return empty project
            project = ProjectStructure(name=project_name)
            project.add_file("main.c", "// Assembly failed\nint main() { return 1; }", "main")
            return project
        
        # Create project structure
        project = ProjectStructure(name=project_name)
        
        # Load technique metadata - use simple dict loading
        import json
        from pathlib import Path
        
        techniques = []
        metadata_dir = Path("techniques/metadata")
        
        for tech_id in technique_ids:
            # Find the technique in metadata files
            for metadata_file in metadata_dir.glob("*.json"):
                if metadata_file.name.startswith("NOCTIS-"):
                    with open(metadata_file, 'r') as f:
                        data = json.load(f)
                        if data.get('id') == tech_id:
                            techniques.append(data)
                            break
        
        # Split techniques into modules
        modules = self.module_splitter.split_techniques(techniques)
        
        # Generate module files
        all_functions = set()
        module_includes = []
        
        for module_name, module_techniques in modules.items():
            logger.info(f"Generating module: {module_name}")
            
            # Generate source file for this module
            module_code = self._generate_module_source(
                module_name, module_techniques, base_result
            )
            
            # Extract functions from this module
            functions = self._extract_functions_from_code(module_code)
            all_functions.update(functions)
            
            # Generate header
            header_code = self.header_generator.generate_header(
                module_name, list(functions)
            )
            
            # Add files to project
            project.add_file(f"{module_name}.c", module_code, "source")
            project.add_file(f"{module_name}.h", header_code, "header")
            module_includes.append(f"#include \"{module_name}.h\"")
        
        # Generate main.c
        main_code = self._generate_main(project_name, module_includes, payload_type, base_result)
        project.add_file("main.c", main_code, "main")
        
        # Add common libraries
        project.libraries.extend([
            "kernel32.lib",
            "user32.lib",
            "ntdll.lib",
            "advapi32.lib"
        ])
        
        logger.info(f"Project generated: {len(project.files)} files")
        
        return project
    
    def _generate_module_source(self, module_name: str,
                                techniques: List[Dict],
                                base_result: GeneratedCode) -> str:
        """Generate source code for a module"""
        
        code = f"""// {module_name.capitalize()} Module
// Auto-generated by Noctis-MCP
// Techniques: {', '.join([t.get('name', 'Unknown') for t in techniques])}

#include "{module_name}.h"
#include <windows.h>
#include <stdio.h>

"""
        
        # Add functions from base result that belong to this module
        # For now, just add placeholder implementations
        
        # Extract relevant functions from base result
        for tech in techniques:
            # Add a simple function for each technique
            tech_name = tech.get('name', 'unknown').replace(' ', '_').replace('-', '_').lower()
            code += f"""
// Technique: {tech.get('name', 'Unknown')}
// ID: {tech.get('id', 'N/A')}
int {module_name}_{tech_name}_init() {{
    // TODO: Implement {tech.get('name', 'Unknown')}
    return 1;
}}

"""
        
        return code
    
    def _extract_functions_from_code(self, code: str) -> List[str]:
        """Extract function signatures from code"""
        import re
        
        # Simple regex to match function definitions
        pattern = r'^([\w\s\*]+)\s+(\w+)\s*\((.*?)\)\s*\{' 
        
        functions = []
        for line in code.split('\n'):
            match = re.match(pattern, line.strip())
            if match:
                functions.append(line.strip()[:-1].strip())  # Remove opening brace
        
        return functions
    
    def _generate_main(self, project_name: str, module_includes: List[str],
                      payload_type: str, base_result: GeneratedCode) -> str:
        """Generate main.c file"""
        
        # Build technique list from technique_ids
        technique_list = ""
        for tech_id in base_result.technique_ids:
            technique_list += f" *   - {tech_id}\n"
        
        main_code = f"""/*
 * {project_name}
 * Auto-generated by Noctis-MCP v1.0-alpha
 * Type: {payload_type}
 * 
 * Techniques Used:
{technique_list} */

#include <windows.h>
#include <stdio.h>

// Module includes
{chr(10).join(module_includes)}

int main(int argc, char* argv[]) {{
    printf("[*] {project_name} v1.0\\n");
    printf("[*] Initializing...\\n");
    
    // TODO: Initialize modules
    // TODO: Execute payload
    
    printf("[+] Complete!\\n");
    return 0;
}}
"""
        
        return main_code


# =============================================================================
# TESTING
# =============================================================================

def test_multi_file_assembler():
    """Test multi-file assembler"""
    
    print("[*] Testing Multi-File Assembler...")
    
    # Create assembler
    assembler = MultiFileAssembler()
    
    # Assemble a project with multiple techniques
    technique_ids = [
        "NOCTIS-T124",  # API Hashing
        "NOCTIS-T118",  # Syscalls
        "NOCTIS-T119",  # Injection (fixed ID)
    ]
    
    project = assembler.assemble_project(
        technique_ids=technique_ids,
        project_name="advanced_loader",
        payload_type="loader"
    )
    
    print(f"\n[+] Project assembled: {project.name}")
    print(f"[+] Files generated: {len(project.files)}")
    print(f"\n[*] File structure:")
    
    for file in project.files:
        print(f"  - {file.filename} ({file.file_type})")
        print(f"    Size: {len(file.content)} bytes")
    
    print(f"\n[*] Libraries: {', '.join(project.libraries)}")
    
    # Now compile it!
    from compilation.multi_file_compiler import MultiFileCompiler
    
    print(f"\n[*] Compiling project...")
    compiler = MultiFileCompiler()
    result = compiler.compile_project(
        project=project,
        architecture="x64",
        optimization="O2",
        output_name="advanced_loader"
    )
    
    if result.success:
        print(f"[+] Compilation successful!")
        print(f"[+] Binary: {result.binary_path}")
        print(f"[+] Time: {result.compilation_time:.2f}s")
    else:
        print(f"[!] Compilation failed:")
        for error in result.errors[:5]:
            print(f"  - {error}")


if __name__ == "__main__":
    test_multi_file_assembler()

